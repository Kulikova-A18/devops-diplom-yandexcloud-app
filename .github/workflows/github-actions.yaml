name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  release:
    types: [ published ]

env:
  REGISTRY: cr.yandex/crps1p5u048a00f4o97j
  IMAGE_NAME: testapp
  K8S_NAMESPACE: app
  DEPLOYMENT_NAME: testapp

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: |
        docker build -t $REGISTRY/$IMAGE_NAME:${GITHUB_SHA::8} .
        docker build -t $REGISTRY/$IMAGE_NAME:latest .

    - name: Run tests
      run: |
        # Здесь можно добавить тесты приложения
        echo "Running tests..."

  push-to-registry:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Yandex Container Registry
      run: |
        # Создаем временный файл с JSON ключом
        cat << 'EOF' > /tmp/key.json
        ${{ secrets.YC_SA_KEY }}
        EOF
        
        # Аутентифицируемся
        cat /tmp/key.json | docker login \
          --username json_key \
          --password-stdin \
          cr.yandex

    - name: Build and push Docker image
      run: |
        # Определяем тег
        if [ "${{ github.event_name }}" == "release" ]; then
          IMAGE_TAG="${{ github.event.release.tag_name }}"
        else
          IMAGE_TAG="${GITHUB_SHA::8}"
        fi
        
        echo "Building image: $REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
        
        # Собираем и пушим образ
        docker build -t $REGISTRY/$IMAGE_NAME:$IMAGE_TAG .
        docker push $REGISTRY/$IMAGE_NAME:$IMAGE_TAG
        
        # Также пушим latest для обычных коммитов
        if [ "${{ github.event_name }}" == "push" ]; then
          docker tag $REGISTRY/$IMAGE_NAME:$IMAGE_TAG $REGISTRY/$IMAGE_NAME:latest
          docker push $REGISTRY/$IMAGE_NAME:latest
        fi

  deploy-to-k8s:
    needs: push-to-registry
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.30.0'

    - name: Configure kubectl for Yandex Cloud
      run: |
        # Создаем kubeconfig
        cat << EOF > kubeconfig.yaml
        apiVersion: v1
        clusters:
        - cluster:
            certificate-authority-data: ${{ secrets.K8S_CA_CERT }}
            server: ${{ secrets.K8S_ENDPOINT }}
          name: yc-k8s-cluster
        contexts:
        - context:
            cluster: yc-k8s-cluster
            user: yc-k8s-user
          name: yc-k8s-context
        current-context: yc-k8s-context
        kind: Config
        users:
        - name: yc-k8s-user
          user:
            token: ${{ secrets.K8S_TOKEN }}
        EOF

    - name: Deploy to Kubernetes
      run: |
        export KUBECONFIG=kubeconfig.yaml
        
        # Определяем версию образа
        if [ "${{ github.event_name }}" == "release" ]; then
          IMAGE_TAG="${{ github.event.release.tag_name }}"
          IMAGE_URL="$REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
        else
          IMAGE_TAG="${GITHUB_SHA::8}"
          IMAGE_URL="$REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
        fi
        
        echo "Deploying image: $IMAGE_URL to namespace: $K8S_NAMESPACE"
        
        # Создаем временный файл манифеста для обновления
        cat << EOF > deployment-patch.yaml
        spec:
          template:
            spec:
              containers:
              - name: $DEPLOYMENT_NAME
                image: $IMAGE_URL
        EOF
        
        # Патчим deployment с новым образом
        kubectl patch deployment $DEPLOYMENT_NAME \
          --namespace $K8S_NAMESPACE \
          --patch-file deployment-patch.yaml
        
        # Ждем rollout
        echo "Waiting for rollout to complete..."
        kubectl rollout status deployment/$DEPLOYMENT_NAME \
          --namespace $K8S_NAMESPACE \
          --timeout=300s
        
        # Проверяем статус
        echo "Current deployment status:"
        kubectl get deployment $DEPLOYMENT_NAME --namespace $K8S_NAMESPACE -o wide
        
        echo "Current pods:"
        kubectl get pods --namespace $K8S_NAMESPACE -l app=$DEPLOYMENT_NAME

    - name: Verify application
      run: |
        export KUBECONFIG=kubeconfig.yaml
        echo "Verifying application health..."
        
        # Получаем IP Load Balancer
        LB_IP=$(kubectl get service testapp-service -n $K8S_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ -n "$LB_IP" ]; then
          echo "Testing application via Load Balancer: http://$LB_IP/"
          curl -f http://$LB_IP/healthz || echo "Health check failed"
        else
          echo "Load Balancer IP not available, testing via NodePort"
          # Тестируем через NodePort на одной из нод
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          NODE_PORT=$(kubectl get service testapp-service -n $K8S_NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')
          curl -f http://$NODE_IP:$NODE_PORT/healthz || echo "Health check failed"
        fi
